Der Weclare-Prototyp zeigt, dass es möglich ist, dank einer JVM-Implementation in JavaScript einen Java-Quelltext in der Browser-Umgebung zu kompilieren und anschließend auszuführen. Gleichzeitig zeigen sich bei dieser Vorgehensweise auch einige Probleme:

\begin{itemize}
    \item \textbf{Größe der Java Runtime:} Die Java-Laufzeitumgebung ist etwa 62 Megabyte groß und muss erst vom Client heruntergeladen werden. Trotz schneller Internetverbindungen erscheint das umständlich zu sein.
    \item \textbf{Performance:} Die DoppioJVM ist langsamer als eine native JVM. Das hat mehrere Gründe, zum Beispiel die Qualität der Implementierung oder der geringere Grad der Optimierung (Ahead-Of-Time-kompilierte vs. interpretierte Sprache).
\end{itemize}

Wäre diese Arbeit zwei oder drei Jahre später entstanden, hätte es vermutlich eine ernstzunehmende Alternative zur Realisierung der Code-Ausführbarkeit gegeben: WebAssembly.

WebAssembly ist ein Standard der bereits von allen großen Browser-Herstellern unterstützt wird (Microsoft, Mozilla, Apple, Google). Es handelt sich bei WebAssembly um ein sogenanntes Compile-Ziel. Also eher nicht um eine Programmiersprache, die manuell von Entwicklern geschrieben wird, sondern um ein Ausgabeformat eines Compilers. WebAssembly erfüllt die gleiche Aufgabe wie Java-Bytecode: Es ist ein plattformunabhängiges Binärformat, das in einer virtuellen Maschine ausgeführt werden kann.

Im Gegensatz zu Java ist die virtuelle Maschine für WebAssembly allerdings bereits Teil der großen Webbrowser und muss nicht extra installiert und heruntergeladen werden. Der Unterschied zu Java setzt sich bei den möglichen Eingabesprachen fort: WebAssembly verfügt über keine „eigene“ Sprache (so wie Java die native, zur JVM gehörende Sprache ist). Stattdessen sollen viele andere, beliebte Sprachen nach WebAssembly kompiliert werden können. Gut unterstützt wird das momentan zum Beispiel von den Sprachen C und Rust.

Es gibt bereits Compiler, die Java-Bytecode nach WebAssembly konvertieren können (zum Beispiel TeaVM). Allerdings ist der TeaVM-Compiler selbst in Java geschrieben. Der Compiler kann also noch nicht im Browser ausgeführt werden. Theoretisch ließe sich dieser Compiler selbst nach WebAssembly kompilieren und könnte dann im Browser funktionieren. Praktisch ist das allerdings aufgrund vieler kleiner Einschränkungen des (noch relativ jungen) WebAssembly-Standards noch nicht so einfach möglich.

Mit steigender Popularität und steigendem Funktionsumfang von WebAssembly ist es sehr wahrscheinlich dass es bald einen Java-zu-WebAssembly-Compiler geben, der selbst in WebAssembly implementiert ist. Damit ließe sich im Browser Java-Quellcode in WebAssembly konvertieren und anschließend ausführen. Das lästige Laden der Java Laufzeitumgebung würde entfallen und die Performance wäre tendenziell höher als bei der Ausführung der DoppioJVM.

Mit WebAssembly wäre es außerdem leichter möglich die Möglichkeit der Code-Ausführung im Browser um weitere Sprachen zu erweitern.