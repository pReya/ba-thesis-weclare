Der Weclare-Prototyp zeigt, dass es möglich ist, dank einer JVM-Implementation in JavaScript einen Java-Quelltext in der Browser-Umgebung zu kompilieren und anschließen auszuführen. Gleichzeitig zeigen sich bei dieser Vorgehensweise auch einige Probleme:

\begin{itemize}
    \item \textbf{Größe der Java Runtime:} Die Java-Laufzeitumgebung ist etwa 62 Megabyte groß und muss erst vom Client heruntergeladen werden. Trotz schneller Internetverbindungen erscheint das nicht sinnvoll.
    \item \textbf{Performance:} Die Doppio-JVM ist langsamer als eine native JVM. Das hat mehrere Gründe: Qualität der Implementierung, geringerer Grad der Optimierung (Compiled vs. Interpreted Sprache).
\end{itemize}

Wäre diese Arbeit zwei oder drei Jahre später entstanden, hätte es eine ernstzunehmende Alternative zur Realisierung der Code-Ausführbarkeit gegeben: WebAssembly.

WebAssembly ist ein Standard der bereits von allen großen Browser-Herstellern unterstützt wird (Microsoft, Mozilla, Apple, Google). Es handelt sich bei WebAssembly um ein sogenanntes Compile-Ziel. Also eher nicht um eine Programmiersprache, die von manuell von Entwicklern geschrieben wird, sondern um ein Ausgabeformat eines Compilers. WebAssembly erfüllt die gleiche Aufgabe wie Java-Bytecode: Ein plattformunabhängiges Binärformat, das in einer virtuellen Maschine ausgeführt werden kann.

Im Gegensatz zu Java ist die virtuelle Maschine für WebAssembly allerdings bereits Teil der großen Webbrowser und muss nicht extra installiert und heruntergeladen werden. Der Unterschied zu Java setzt sich bei den möglichen Eingabesprachen fort: WebAssembly verfügt über keine "eigene" Sprache. Stattdessen sollen viele andere, beliebte Sprachen nach WebAssembly kompiliert werden können. Gut unterstützt ist das momentan vor allem mit den Sprachen C und Rust.

Es gibt bereits Compiler, die Java-Bytecode nach WebAssembly konvertieren können. Allerdings ist der TeaVM-Compiler selbst in Java geschrieben. Der Compiler kann also nicht im Browser ausgeführt werden. Eine Implementation eines CRA wäre mithilfe von TeaV; zwar möglich, jedoch müsste die Kompilierung auf einem zusätzlichen Server in einer Java-Umgebung stattfinden.

Mit steigender Popularität und steigendem Funktionsumfang von WebAssembly ist es sehr wahrscheinlich dass es bald einen Java-zu-WebAssembly-Compiler gibt, der selbst in WebAssembly implementiert ist. Damit ließe sich im Browser Java-Quellcode in WebAssembly konvertieren und anschließend ausführen. Das lästige Laden der Java Laufzeitumgebung würde entfallen und die Performance wäre tendenziell höher, da es sich um einen Ahead-of-Time-Compiler handelt, der einen hohen Optimierungsgrad erwirken könnte.