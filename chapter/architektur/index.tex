In diesem Kapitel wird erörtert, wie und aus welchen Elementen, sich das einstehende Softwareprojekt gliedert. Dabei wird jedoch nur die grobe Struktur des Projekt und die für den Anwendungsfall relevanten Aspekte beleuchtet.

Das Projekt ist in \textit{Java} implementiert. Um grafische Benutzeroberflächen zu ermöglichen, wird \textit{JavaFX} eingesetzt. Das Projekt richtet sich nach dem MVC-Modell aus \cite{web:mvc}.

\begin{sloppypar}
Kernaspekt des Projekt ist der Agent. Dieser ist in Form der Klasse \texttt{codyAgent.CoDyAgent} implementiert, die die Klasse \texttt{jade.core.Agent} erweitert. Ein \textit{CoDy-Agent} implementiert, abgesehen von der Wegplanung, die Logik des CoDy Algorithmus. Die Wegplanung ist in Objekten gekapselt, die den verschiedenen Kartentypen des CoDy Algorithmus entsprechen. Diese werden jedoch direkt von dem Agenten gesteuert. Wie in \cite{book:jade} empfohlen, implementiert der CoDy Agent sein Verhalten als innere Klassen.

\paragraph{PlanningBehaviour}
Das \textit{PlanningBehaviour} übernimmt mehrere Aufgaben. Zum einen führt es die Wegplanung aus, zum anderen wandelt es den geplanten Weg als \texttt{String} im \textit{JSON} Format um. Übernimmt also das \textit{Marshalling}. Außerdem wird dieser \texttt{String} als Nachricht an alle Agenten gesendet. Als Performativ wird hier "'Informieren"', also \texttt{jade.lang.acl.ACLMessage.INFORM}, genutzt. Das \textit{PlanningBehaviour} ist ein \texttt{CyclicBehaviour} mit zwei Status. Die Statusm sind wie in \cite{book:jade} vorgeschlagen, als \texttt{switch case} umgesetzt. Befindet sich dieses Verhalten im ersten Status, dann wird darauf gewartet, dass von allen Agenten, auf die gewartet wird, eine Nachricht eintrifft. Im zweiten Status findet dann der Berechnungsschritt, also die Wegplanung, wie in \ref{chap:algorithmus} beschrieben, statt.
\end{sloppypar}

\paragraph{MessageReceiveBehaviour}
Auch das \textit{MessageReceiveBehaviour} ist ein \texttt{CyclicBehaviour}. Dieses kontrolliert regelmäßig, ob neue Nachrichten vorliegen und übernimmt dann das \textit{Unmarshalling}.

\paragraph{MovementBehaviour}
Dieses Behaviour ist ein \texttt{TickerBehaviour}. In regelmäßigen, durch eine Periode vorgegebenen, Abständen wird der aktuelle Bewegungsplan gelesen. Das MovementBehaviour steuert dann über den \textit{Hardware Abstraction Layer} (HAL), die nächste durchzuführende Bewegung. 

\paragraph{CoDyAgentDiscoveryBehaviour}
Das \textit{CoDyAgentDiscoveryBehaviour} ist ein \texttt{OneShotBehaviour}. Es sucht jene Agenten, die bei dem \texttt{DFService} einen CoDy-Service registriert haben und speichert diese in eine dem Agenten verfügbare Liste.

Ein Agent kann sich nicht selber ins Leben rufen. Diese Aufgabe wird von der Simulationsumgebung übernommen. Die Simulationsumgebung ist Teil eines \texttt{Controllers} des \textit{JavaFX} Projekts. Der \texttt{Controller} stellt den HAL, startet die Simulation und steuert die grafischen Bewegungen der Agenten. Um eine Simulation zu starten, wird im ersten Schritt eine JSON-Datei eingelesen, die die Karteninformationen, Parameter sowie die Start- und Zielpositionen der Agenten enthält. Daraufhin wird über die \texttt{jade.core.Runtime} die JADE Umgebung gestartet. Über diese Umgebung werden die Agenten initialisiert und gestartet. 
Der angesprochene \texttt{HAL} ist als innere Klasse implementiert und erfüllt das \texttt{CoDyAgentHAL} Interface. Die \texttt{SimulationCoDyHAL} ermöglicht dem \texttt{Controller} die Bewegungen der CoDy Agenten darzustellen. Außerdem werden die Bewegungen aufgezeichnet, so das sie nach der eigentlichen Simulation wiedergegeben werden können. Nachdem die Agenten initialisiert und gestartet sind, wartet der Simulator, bis alle Agenten ihre jeweiligen Ziele erreicht und schließt dann die JADE Umgebung. 
