Im Rahmen dieser Arbeit wird ein CRS entworfen und prototypisch implementiert, welches die besagten Kern-Anforderungen erfüllt. Die entstehende Software hört auf den Namen Weclare (ein Akronym für „\textbf{We}b \textbf{Cla}ssroom \textbf{Re}sponse (System)“. Der gesamte Quelltext zu dem Projekt findet sich in einem öffentlichen Github-Repository und eine öffentlich zugängliche Version der Software kann unter \texttt{www.weclare.de} aufgerufen werden. Insgesamt hat die Implementierung einen Umfang von rund 6000 Zeilen Code (vergleichbar mit dem Vorbild StuReSy).

Gleichzeitig soll das neue System mit bestehenden Daten aus StuReSy funktionieren. Aus diesem Grund wird außerdem ein Kommandozeilen-Werkzeug entwickelt, welches Fragensätze vom XML-basierten StuReSy-Format in das JSON-basierte Weclare-Format konvertiert. Auch dieses Hilfsprogramm kann in einem öffentlichen Github-Repository gefunden werden. https://github.com/pReya/weclare-sturesy-converter

\section{Umsetzung als Single Page Application}
\label{chap:react_einfuehrung}
Um eine webbasierte Anwendung zu erstellen, die ohne einen zentralen Server auskommt, muss die Software komplett clientseitig in einem Browser ausgeführt werden. Ein klassisches Backend, also eine Datenschicht (üblicherweise handelt es sich bei den meisten Web-Applikationen mindestens um eine Zwei-Schichten-Architektur) existiert nicht, beziehungsweise ist in die Präsentationsschicht integriert. Das bedingt die Kategorisierung einer solchen Anwendung als „Fat Client“.

Für diesen Zweck bietet es sich an, die Software als sogenannte „Single Page Application“ zu implementieren. Das bedeutet, dass die gesamte Anwendung nur eine einzige Webseite lädt und diese dann dynamisch verändert wird. Weitere Inhalte werden bei Bedarf asynchron (ohne Blockieren der Seite) nachgeladen, es wird jedoch keine neue Seite geladen. Damit wird auch eine hohe Autarkie vom Webserver erreicht, da dieser nur mit wenigen Requests (ein Request pro Nutzer – ausgenommen der Features in Kapitel X.X) umgehen muss. Die Anforderungen an den Webserver auf dem die Anwendung bereitgestellt wird sind sehr gering, er muss lediglich eine einzige JavaScript-Datei ausliefern (ausgenommen Bilder, Icons, Schriftarten, Stylesheets und ähnliches).

\subsection{Einführung in das React-Framework}
Als Framework für die Implementierung einer solchen Single Page Application wird das React-Framework\cite{web:react} ausgewählt. Das Open-Source-Projekt existiert seit 2013 und wird von Facebook finanziert. Es gehört zu den populärsten Frameworks zum Erstellen von Benutzeroberflächen und Web-Applikationen und ist dem Autor der Arbeit bereits vertraut.

Um einige Implementationsdetails nachzuvollziehen, erfolgt an dieser Stelle eine kleine Einführung in Grundkonzepte von React.

\subsubsection{Komponenten}
Die elementaren Bausteine einer React-Anwendung sind \texttt{Komponenten}. Die React-Dokumentation beschreibt die Aufgabe von Komponenten wie folgt\cite{web:react}:
\begin{quotation}
„Build encapsulated components that manage their own state, then compose them to make complex UIs.“
\end{quotation}

Ein Komponente ist eine autarke und wiederverwendbare Einheit und kapselt meistens sowohl Struktur, Aussehen als auch Logik. Komponenten werden häufig als Klasse implementiert (können aber in einfachen Fällen auch als Funktion implementiert werden) und erben von der Klasse \texttt{React.Component}. Komponenten müssen nur über eine \texttt{render()}-Funktion verfügen, die HTML oder andere React-Komponenten zurückliefert. Eine sehr simple, statische Komponente könnte so aussehen:

\begin{lstlisting}
import React from "react";

class Greeting extends React.Component {
  render() {
    return React.createElement("div", null, "Hello there!");
  }
}
\end{lstlisting}

Da der Aufruf React.createElement() nicht so schön zu lesen ist, wie die Notation eines XML-Tags (<div>...</div>) wird im React-Umfeld häufig eine Syntax-Erweiterung namens JSX (JavaScript Syntax Extension) verwendet um React-Komponenten zu beschreiben. JSX wird mit einem Transpiler während des Build-Prozesses in herkömmliches JavaScript umgewandelt. Äquivalent zum letzten Beispiel wäre daher die folgende Variante unter Einbeziehung von JSX-Syntax:

\begin{lstlisting}
import React from 'react';

class Greeting extends React.Component {
    render() {
        return <div>Hello there!</div>;
    }
}
\end{lstlisting}

Um Komponenten dynamisch zu machen, können über sogenannte \texttt{Properties} Daten an Komponenten übergeben werden:

\begin{lstlisting}
import React from "react";

class Greeting extends React.Component {
  render() {
    return <div>Hello, {this.props.name}!</div>;
  }
}
\end{lstlisting}

Properties werden wie andere HTML-Attribute auch einfach hinter den Namen der Komponente innerhalb des zugehörigen Tags in die Instanziierung einer Komponente integriert:

\begin{lstlisting}
import React from "react";

class GreetAllFriends extends React.Component {
  render() {
    return (
      <div>
        <Greeting name="Michael" />
        <Greeting name="Karla" />
      </div>
    );
  }
}
\end{lstlisting}

\texttt{Properties} werden also verwendet um Daten in Komponenten hinein zu reichen. Außerdem kümmert sich React automatisch um das Aktualisieren der aktuellen Ansicht, sobald sich eine Property ändert. Dabei verwendet React schnelle und intelligente Verfahren, um immer nur die nötigen Elemente zu aktualisieren, und nicht die gesamte Seite zu erneuern.

Properties können nicht modifiziert werden – wie die meisten Objekte innerhalb von React sind sie immutable. Wenn Daten innerhalb einer Komponente modifiziert werden sollen gehören sie in den internen, modifizierbaren \texttt{state} dieser Komponente:

\begin{lstlisting}
import React from "react";

class BusyOrNot extends React.Component {
  state = {
    busy: false
  };

  toggleBusy() {
    this.setState(prevState => ({
      busy: !prevState.busy
    }));
  }

  render() {
    return (
      <div>
        <div>This user is {busy ? "busy" : "not busy"}!</div>
        <button type="button" onClick={this.toggleBusy}>
          Change Busy State
        </button>
      </div>
    );
  }
}
\end{lstlisting}
Bedingt durch die statische Natur der Properties, forciert React einen unidirektionalen Datenfluss. Daten können nur von „oben nach unten“ (in Bezug auf die Baumstruktur im Document Object Model einer Seite) durch eine Anwendung fließen. Möchten zwei Komponenten an unterschiedlichen Stellen auf die gleichen Daten zugreifen, dann sollte der entsprechende \texttt{state} in einer gemeinsamen Eltern-Komponente gehalten werden. \newline


Da dieses Muster bei großen Anwendungen aber schnell zu sehr aufwendigem „Durchstecken“ von Properties (Prop Drilling) durch mehrere Komponenten-Ebenen führt, gibt es eine populäre Erweiterung für React zur Verwaltung eines globalen States in der gesamten Anwendung: das sogenannte Flux-Muster.


\subsubsection{State Management mit Redux}
Das Flux-Entwurfsmuster ist ebenfalls eine Entwicklung von Facebook. Prinzipiell handelt es sich um ein abstraktes Entwurfsmuster, das in vielen Sprachen angewendet werden kann. Etabliert hat es sich jedoch gerade in Kombination mit React-Anwendungen. Die bekannteste Implementation, die auch in dieser Arbeit verwendet wird, hört auf den Namen Redux.

Im Flux-Muster geht es darum, eine zentrale Zustands-Verwaltung für eine Anwendung einzurichten, eine „Single Source of Truth“. Dieser zentrale Ort wird als „Store“ bezeichnet. Ein Store beinhaltet typischerweise solche Daten, die für die gesamte Anwendung relevant sind. Parallel dazu kann es aber weiterhin Komponenten geben, die einen eigenen, lokalen State verwalten, wenn dieser nicht für die gesamte Anwendung relevant ist (zum Beispiel der Status von UI-Elementen).

Einzelne React-Komponenten können mit einem Store durch einen Publish/Subscribe-Mechanismus verbunden werden. Die Daten aus dem Store stehen der Komponente dann als Property zur Verfügung. Ändern sich die Daten im Store, dann wird die verbundene Komponente sofort benachrichtigt und bei einer Änderung der Properties ggf. neu gerendert.

Ähnlich wie die Properties in React, sind auch die Daten in einem Store unveränderlich. Änderungen in einem Store müssen mithilfe von \texttt{Actions} realisiert werden. Bei einer Action handelt es sich lediglich um ein Objekt, welches die Art der Änderung in einem Store beschreibt. Die konkrete Umsetzung einer Änderungsoperation erfolgt im zugehörigen \texttt{reducer}. Ein einfacher Reducer zum Hinzufügen einer Frage zu einem Fragekatalog könnte so aussehen:

\begin{lstlisting}
const questionEditor = (state = [], action) => {
  switch (action.type) {
    case ADD_QUESTION: {
      return [... state, createNewQuestion()];
    }
  }
};

\end{lstlisting}

\subsection{Beispiele für die Umsetzung mittels React}



%
\section{Variable Server-Client-Architektur}
\label{chap:p2p}
Um Unabhängigkeit von einem dedizierten, zentralen Server zu erreichen kann jeder Weclare-Nutzer zum Start einer Sitzung, also zur Laufzeit entscheiden, welche Rolle er in der Topologie einnehmen will (Server oder Client). Unabhängig von der Wahl wird stets der gleiche Code vom Server geladen. Das Programm ist in dieser Hinsicht also vielgestaltig. Im laufenden Fragebetrieb gibt es dann eine fixe Rollenzuteilung unter den Teilnehmern: Der Rechner des Dozent agiert als Server, die Rechner der Studenten sind Clients und somit ergibt sich eine klassische Stern-Topologie.

Auch wenn einige Merkmale einer Peer-to-Peer-Architektur erfüllt (die Teilnehmer führen die gleiche Software aus und sind heterogen zusammengesetzt) werden, handelt es sich zur Laufzeit einer Fragerunde um eine klassische Client-Server-Struktur.

Die Entscheidung, dass jeder Teilnehmer variabel entscheiden kann, ob er die Rolle als Server oder Client einnehmen will bedeutet, dass Aspekte wie NAT und der Austausch der IP-Adressen (das Signalling) berücksichtigt werden müssen.

Der Zugriff auf Schnittstellen des Betriebssystems (wie etwa das Netzwerk) durch Browser-Inhalte ist aus Sicherheitsgründen in JavaScript stark eingeschränkt. Die einzige bekannte Möglichkeit, eine omnidirektionale Verbindung zwischen Browsern zu realisieren ist der relativ neue WebRTC-Standard (Abgekürzt für „Web Realtime Communication“).

WebRTC wird hauptsächlich für Echtzeit-Video- und Audio-Anwendungen eingesetzt. Viele Video- und Audiotelefonie-Lösungen (zum Beispiel Skype oder Discord) basieren inzwischen auf dem WebRTC-Protokoll. Neben Audio- und Videoinhalten können aber auch beliebige andere Daten übertragen werden. WebRTC beinhaltet keine Anweisungen für den Austausch der IP-Adressen zwischen beteiligten Parteien. Dieser Teil, das sogenannte Signalling, ist nicht Teil des Standards und muss selbst implementiert werden. Der Aufwand dafür ist relativ hoch, wenn alle gängigen Netzwerk-Situationen berücksichtigt werden sollen. Deswegen wird beim Weclare-Prototyp eine OpenSource-Bibliothek namens PeerJS verwendet, die WebRTC in eine sehr einfache API kapselt und das Signalling-Verfahren beisteuert.

Die mehrfach formulierte Anforderung, keinen dedizierten Server zu benötigen, kann aufgrund des notwendigen Signallings also nicht vollständig erfüllt werden und muss präzisiert werden: Ein dedizierter Server wird lediglich zum Austausch der IP-Adressen der Teilnehmer benötigt. Anwendungsdaten werden nie über einen zentralen Server, sondern immer nur zwischen den Teilnehmern verschickt.

Die PeerJS-Library ermöglicht den Aufbau einer Datenverbindung zwischen zwei Browsern in sehr simplen Aufrufen:

Zunächst müssen Client und Server ein Peer-Objekt erzeugen. Als Parameter kann an dieser Stelle eine ID mitgegeben werden, unter welcher der zugehörige Peer beim Signalling-Server bekannt gemacht wird. Optional kann außerdem ein eigener Signalling-Server eingefügt werden. Die Standard-Einstellung verwendet den kostenlosen und öffentlichen Signalling-Server, der von den PeerJS-Autoren betrieben wird.

\begin{lstlisting}
import Peer from "peerjs";

const peer = createPeer();
\end{lstlisting}

Anschließend können an dem neuen Peer-Objekt diverse Callback-Methoden registriert werden, die den weiteren Gebrauch bestimmen. So kann zum Beispiel der Server seine neu erstellte ID kundtun und auf eingehende Verbindungen und Daten reagieren:

\begin{lstlisting}
peer.on("open", id => {
  console.log(`Successfully created peer: ${id}`);
});

peer.on("connection", conn => {
  console.log(`New client connected: ${conn.peer}`);
  conn.on("data", data => {
    switch (data.type) {
      case "answer":
        // Do something
        break;
      case "heartbeat":
        // Do something else
        break;
      default:
      // Noop
    }
  });
});
\end{lstlisting}

Auf der Gegenseite, beim Client kann die Verbindung einfach über die connect() Methode aufgebaut werden. Anschließend kann über das daraus zurückgelieferte Connection-Objekt eine Nachricht verschickt werden:

\begin{lstlisting}
const connection = peer.connect("server-id");
connection.send("Hello world!");
\end{lstlisting}


%
\section{Formatierung}
\label{chap:metriken}
\input{chapter/entwurf/format.tex}
%
\section{Ausführung}
\label{chap:ausfuehrung}
\input{chapter/entwurf/ausfuehrung.tex}